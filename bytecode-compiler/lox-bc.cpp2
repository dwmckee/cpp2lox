// cpp2lox
//
// lox bytecode compiler/vm in cpp2

// As of April 2023 no cpp2 syntax for enums
enum OpCode : uint8_t
{
  CONSTANT,
  RETURN
};

// Artifically limited dynamic array to match the behavior of lox
// Implements only what is needed.
Vec256: <T> type =
{
  v: std::vector<T>;

  operator[]: (this, i: u8) -> _ = { return v[i]; }
  push_back: (inout this, newValue: T) = {
    if v.size()>(255 as u8) { std::runtime_error("Array full"); }
    v.push_back(newValue);
  }
  size: (this) -> u8 = {  return cpp2::unsafe_narrow<u8>(v.size()); }
}

Value: type =
{
  value: double = 0;

  operator=: (out this) = {}
  operator=: (out this, dval: double) = { value = dval; }
  operator=: (out this, in that) = { value = that.value; }
  print: (this) = { printf("%g", value); }
}

constantInstruction: (name: std::string_view, chunk: Chunk, offset: u8) -> u8 =
{
  constantIdx:= chunk[offset+1];
  printf("%-16s [%3d] = ", name.data(), constantIdx);
  value:= chunk.constant(constantIdx);
  value.print();
  printf("\n");
  return offset+2;
}

simpleInstruction: (name: std::string_view, offset: u8) -> u8 = 
{
  printf("%s\n", name.data());
  return offset+1;
}
 
unknownInstruction: (opcode: u8, offset: u8) -> u8 = 
{
  printf("+++Unknown opcode 0x%02x+++\n", opcode as u8);
  return offset+1;
}

// Uses switch so needs to be in cpp1 syntax (as of April 2023)
//
// The awkward argument list comes from order of declaration issues
uint8_t disassembleOpcode(const Chunk & chunk, uint8_t offset, uint8_t opcode)
{
  switch (opcode)
  {
    case OpCode::CONSTANT:
      return constantInstruction("OP_CONSTANT", chunk, offset);
    case OpCode::RETURN:
      return simpleInstruction("OP_RETURN", offset);
    default:
      return unknownInstruction(opcode, offset);
  }
}

Chunk: type =
{
  code: Vec256<u8> = ();
  constants: Vec256<Value> = ();
  lines: Vec256<int> = ();
  
  operator=: (out this) = {}
  
  operator[]: (this, i: u8) -> u8 = { return code[i]; }
  addConstant: (inout this, value: Value) -> u8 =
  {
    constants.push_back(value);
    return constants.size()-1;
  }
  byteCode: (this, index: u8) -> u8 = { return code[index]; }
  constant: (this, index: u8) -> Value = { return constants[index]; }
  disassemble: (this, name: std::string_view) =
  {
    std::cout << "== " << name << " ==" << std::endl;
    (copy i: size_t = 0) while i<size()
    {
      i = disassembleInstruction(i);
    }
  }
  disassembleInstruction: (this, offset: u8) -> u8 =
  {
    printf("%4u ", offset);
    if (offset>0u && line(offset)!=line(offset-1))
    {
      printf("  |  ");
    }
    else
    {
      printf("%4d ", line(offset));
    }
    opcode:= byteCode(offset);
    return disassembleOpcode(this, offset, opcode);
}
  line: (this, offset: size_t) -> int = {
    return lines[offset];  
  }
  size: (this) -> u8 = { return code.size(); }
  write: (inout this, byte: u8, lineNum: int) = {
    code.push_back(byte);
    lines.push_back(lineNum);
  }
}

main: () -> int =
{
  chunk: Chunk = ();

  constant:= chunk.addConstant(Value(1.2));
  chunk.write(OpCode::CONSTANT, 123);
  chunk.write(constant, 123);

  chunk.write(OpCode::RETURN, 124);

  chunk.disassemble("test chunk");
  return 0;
}
